// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: squad/marketmaker/v1beta1/marketmaker.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/regen-network/cosmos-proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the set of params for the marketmaker module.
type Params struct {
	IncentiveBudgetAddress string                                   `protobuf:"bytes,1,opt,name=incentive_budget_address,json=incentiveBudgetAddress,proto3" json:"incentive_budget_address,omitempty" yaml:"incentive_budget_address"`
	DepositAmount          github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=deposit_amount,json=depositAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"deposit_amount" yaml:"deposit_amount"`
	IncentivePairs         []IncentivePair                          `protobuf:"bytes,3,rep,name=incentive_pairs,json=incentivePairs,proto3" json:"incentive_pairs" yaml:"incentive_pairs"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_bbea9ddeaf9fb816, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

type IncentivePair struct {
	PairName         string                                 `protobuf:"bytes,1,opt,name=pair_name,json=pairName,proto3" json:"pair_name,omitempty"`
	PairId           uint64                                 `protobuf:"varint,2,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty" yaml:"pair_id"`
	UpdateTime       time.Time                              `protobuf:"bytes,3,opt,name=update_time,json=updateTime,proto3,stdtime" json:"update_time" yaml:"update_time"`
	MinDepth         github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=min_depth,json=minDepth,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_depth" yaml:"min_depth"`
	MaxSpread        github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=max_spread,json=maxSpread,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_spread" yaml:"max_spread"`
	MinWidth         github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=min_width,json=minWidth,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_width" yaml:"min_width"`
	RemnantThreshold github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=remnant_threshold,json=remnantThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"remnant_threshold" yaml:"remnant_threshold"`
	DailyUptime      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=daily_uptime,json=dailyUptime,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"daily_uptime" yaml:"daily_uptime"`
	MonthlyUptime    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=monthly_uptime,json=monthlyUptime,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"monthly_uptime" yaml:"monthly_uptime"`
	IncentiveWeight  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=incentive_weight,json=incentiveWeight,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"incentive_weight" yaml:"incentive_weight"`
}

func (m *IncentivePair) Reset()         { *m = IncentivePair{} }
func (m *IncentivePair) String() string { return proto.CompactTextString(m) }
func (*IncentivePair) ProtoMessage()    {}
func (*IncentivePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_bbea9ddeaf9fb816, []int{1}
}
func (m *IncentivePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncentivePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncentivePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncentivePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncentivePair.Merge(m, src)
}
func (m *IncentivePair) XXX_Size() int {
	return m.Size()
}
func (m *IncentivePair) XXX_DiscardUnknown() {
	xxx_messageInfo_IncentivePair.DiscardUnknown(m)
}

var xxx_messageInfo_IncentivePair proto.InternalMessageInfo

type Incentive struct {
	Address   string                                   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
	Claimable github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=claimable,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"claimable" yaml:"claimable"`
}

func (m *Incentive) Reset()         { *m = Incentive{} }
func (m *Incentive) String() string { return proto.CompactTextString(m) }
func (*Incentive) ProtoMessage()    {}
func (*Incentive) Descriptor() ([]byte, []int) {
	return fileDescriptor_bbea9ddeaf9fb816, []int{2}
}
func (m *Incentive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Incentive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Incentive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Incentive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Incentive.Merge(m, src)
}
func (m *Incentive) XXX_Size() int {
	return m.Size()
}
func (m *Incentive) XXX_DiscardUnknown() {
	xxx_messageInfo_Incentive.DiscardUnknown(m)
}

var xxx_messageInfo_Incentive proto.InternalMessageInfo

type MarketMaker struct {
	Address  string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
	PairId   uint64 `protobuf:"varint,2,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty" yaml:"pair_id"`
	Eligible bool   `protobuf:"varint,3,opt,name=eligible,proto3" json:"eligible,omitempty" yaml:"eligible"`
}

func (m *MarketMaker) Reset()         { *m = MarketMaker{} }
func (m *MarketMaker) String() string { return proto.CompactTextString(m) }
func (*MarketMaker) ProtoMessage()    {}
func (*MarketMaker) Descriptor() ([]byte, []int) {
	return fileDescriptor_bbea9ddeaf9fb816, []int{3}
}
func (m *MarketMaker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketMaker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketMaker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketMaker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketMaker.Merge(m, src)
}
func (m *MarketMaker) XXX_Size() int {
	return m.Size()
}
func (m *MarketMaker) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketMaker.DiscardUnknown(m)
}

var xxx_messageInfo_MarketMaker proto.InternalMessageInfo

type Deposit struct {
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount" yaml:"amount"`
}

func (m *Deposit) Reset()         { *m = Deposit{} }
func (m *Deposit) String() string { return proto.CompactTextString(m) }
func (*Deposit) ProtoMessage()    {}
func (*Deposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_bbea9ddeaf9fb816, []int{4}
}
func (m *Deposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deposit.Merge(m, src)
}
func (m *Deposit) XXX_Size() int {
	return m.Size()
}
func (m *Deposit) XXX_DiscardUnknown() {
	xxx_messageInfo_Deposit.DiscardUnknown(m)
}

var xxx_messageInfo_Deposit proto.InternalMessageInfo

type DepositRecord struct {
	Address string                                   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
	PairId  uint64                                   `protobuf:"varint,2,opt,name=pair_id,json=pairId,proto3" json:"pair_id,omitempty" yaml:"pair_id"`
	Amount  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount" yaml:"amount"`
}

func (m *DepositRecord) Reset()         { *m = DepositRecord{} }
func (m *DepositRecord) String() string { return proto.CompactTextString(m) }
func (*DepositRecord) ProtoMessage()    {}
func (*DepositRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_bbea9ddeaf9fb816, []int{5}
}
func (m *DepositRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositRecord.Merge(m, src)
}
func (m *DepositRecord) XXX_Size() int {
	return m.Size()
}
func (m *DepositRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DepositRecord proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Params)(nil), "squad.marketmaker.v1beta1.Params")
	proto.RegisterType((*IncentivePair)(nil), "squad.marketmaker.v1beta1.IncentivePair")
	proto.RegisterType((*Incentive)(nil), "squad.marketmaker.v1beta1.Incentive")
	proto.RegisterType((*MarketMaker)(nil), "squad.marketmaker.v1beta1.MarketMaker")
	proto.RegisterType((*Deposit)(nil), "squad.marketmaker.v1beta1.Deposit")
	proto.RegisterType((*DepositRecord)(nil), "squad.marketmaker.v1beta1.DepositRecord")
}

func init() {
	proto.RegisterFile("squad/marketmaker/v1beta1/marketmaker.proto", fileDescriptor_bbea9ddeaf9fb816)
}

var fileDescriptor_bbea9ddeaf9fb816 = []byte{
	// 871 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcd, 0x6f, 0xdc, 0x44,
	0x14, 0x5f, 0x27, 0x61, 0x3f, 0x66, 0xd9, 0x34, 0x9d, 0x42, 0x71, 0x82, 0xb4, 0x8e, 0x06, 0x09,
	0xad, 0x54, 0x6a, 0xab, 0x85, 0x53, 0x6e, 0xd9, 0x06, 0xa1, 0x45, 0x6a, 0x55, 0x99, 0xa2, 0x4a,
	0x20, 0x64, 0x8d, 0xd7, 0xc3, 0xee, 0x28, 0x3b, 0x1e, 0xd7, 0x33, 0xdb, 0x24, 0x07, 0xee, 0x20,
	0x2e, 0x3d, 0x72, 0xac, 0xc4, 0x0d, 0xfe, 0x0b, 0x4e, 0x3d, 0xf6, 0x88, 0x38, 0x6c, 0x51, 0x72,
	0x41, 0x1c, 0xf7, 0x2f, 0x40, 0xf3, 0x61, 0xaf, 0xb7, 0x55, 0x15, 0x8c, 0x84, 0x7a, 0xf2, 0xcc,
	0xfb, 0xfa, 0xbd, 0xdf, 0x9b, 0x79, 0x6f, 0x0c, 0x6e, 0x88, 0x47, 0x73, 0x9c, 0x04, 0x0c, 0xe7,
	0xc7, 0x44, 0x32, 0x7c, 0x4c, 0xf2, 0xe0, 0xf1, 0xad, 0x98, 0x48, 0x7c, 0xab, 0x2a, 0xf3, 0xb3,
	0x9c, 0x4b, 0x0e, 0x77, 0xb5, 0xb1, 0x5f, 0x55, 0x58, 0xe3, 0xbd, 0x77, 0x26, 0x7c, 0xc2, 0xb5,
	0x55, 0xa0, 0x56, 0xc6, 0x61, 0x6f, 0x77, 0xcc, 0x05, 0xe3, 0x22, 0x32, 0x0a, 0xb3, 0xb1, 0xaa,
	0xbe, 0xd9, 0x05, 0x31, 0x16, 0xa4, 0x84, 0x1c, 0x73, 0x9a, 0x5a, 0xbd, 0x37, 0xe1, 0x7c, 0x32,
	0x23, 0x81, 0xde, 0xc5, 0xf3, 0x6f, 0x03, 0x49, 0x19, 0x11, 0x12, 0xb3, 0xcc, 0x18, 0xa0, 0xe5,
	0x06, 0x68, 0xde, 0xc7, 0x39, 0x66, 0x02, 0x7e, 0x03, 0x5c, 0x9a, 0x8e, 0x49, 0x2a, 0xe9, 0x63,
	0x12, 0xc5, 0xf3, 0x64, 0x42, 0x64, 0x84, 0x93, 0x24, 0x27, 0x42, 0xb8, 0xce, 0xbe, 0x33, 0xe8,
	0x0c, 0x3f, 0x58, 0x2e, 0x3c, 0xef, 0x0c, 0xb3, 0xd9, 0x01, 0x7a, 0x9d, 0x25, 0x0a, 0xaf, 0x97,
	0xaa, 0xa1, 0xd6, 0x1c, 0x1a, 0x05, 0xfc, 0xd1, 0x01, 0xdb, 0x09, 0xc9, 0xb8, 0xa0, 0x32, 0xc2,
	0x8c, 0xcf, 0x53, 0xe9, 0x6e, 0xec, 0x6f, 0x0e, 0xba, 0xb7, 0x77, 0x7d, 0x4b, 0x49, 0x91, 0x28,
	0x4a, 0xe1, 0xdf, 0xe1, 0x34, 0x1d, 0x8e, 0x9e, 0x2d, 0xbc, 0xc6, 0x72, 0xe1, 0xbd, 0x6b, 0x40,
	0xd7, 0xdd, 0xd1, 0x2f, 0x2f, 0xbc, 0xc1, 0x84, 0xca, 0xe9, 0x3c, 0xf6, 0xc7, 0x9c, 0xd9, 0xc2,
	0xd8, 0xcf, 0x4d, 0x91, 0x1c, 0x07, 0xf2, 0x2c, 0x23, 0x42, 0x47, 0x12, 0x61, 0xcf, 0x3a, 0x1f,
	0x6a, 0x5f, 0xf8, 0x08, 0x5c, 0x59, 0x51, 0xc8, 0x30, 0xcd, 0x85, 0xbb, 0xa9, 0xb3, 0x19, 0xf8,
	0xaf, 0x3d, 0x1e, 0x7f, 0x54, 0x78, 0xdc, 0xc7, 0x34, 0x1f, 0xf6, 0x6d, 0x72, 0xd7, 0x5f, 0xae,
	0x88, 0x0e, 0x87, 0xc2, 0x6d, 0x5a, 0x35, 0x17, 0x07, 0xed, 0xef, 0x9f, 0x7a, 0x8d, 0x9f, 0x9e,
	0x7a, 0x0d, 0xf4, 0x6b, 0x0b, 0xf4, 0xd6, 0x62, 0xc1, 0xf7, 0x41, 0x47, 0x79, 0x45, 0x29, 0x66,
	0xc4, 0x14, 0x3b, 0x6c, 0x2b, 0xc1, 0x3d, 0xcc, 0x08, 0xbc, 0x01, 0x5a, 0x5a, 0x49, 0x13, 0x77,
	0x63, 0xdf, 0x19, 0x6c, 0x0d, 0xe1, 0x72, 0xe1, 0x6d, 0x1b, 0x54, 0xab, 0x40, 0x61, 0x53, 0xad,
	0x46, 0x09, 0xfc, 0x1a, 0x74, 0xe7, 0x59, 0x82, 0x25, 0x89, 0xd4, 0x51, 0xbb, 0x9b, 0xfb, 0xce,
	0xa0, 0x7b, 0x7b, 0xcf, 0x37, 0xf7, 0xc0, 0x2f, 0xee, 0x81, 0xff, 0xa0, 0xb8, 0x07, 0x25, 0x0d,
	0x68, 0x02, 0x56, 0x9c, 0xd1, 0x93, 0x17, 0x9e, 0x13, 0x02, 0x23, 0x51, 0x0e, 0x30, 0x02, 0x1d,
	0x46, 0xd3, 0x28, 0x21, 0x99, 0x9c, 0xba, 0x5b, 0xfa, 0x4e, 0x0c, 0x95, 0xfb, 0x1f, 0x0b, 0xef,
	0xc3, 0x7f, 0x71, 0x12, 0xa3, 0x54, 0x2e, 0x17, 0xde, 0x8e, 0x01, 0x2a, 0x03, 0xa1, 0xb0, 0xcd,
	0x68, 0x7a, 0xa4, 0x96, 0x30, 0x06, 0x80, 0xe1, 0xd3, 0x48, 0x64, 0x39, 0xc1, 0x89, 0xfb, 0x96,
	0x46, 0xb8, 0x53, 0x03, 0xe1, 0x88, 0x8c, 0x97, 0x0b, 0xef, 0xaa, 0x45, 0x28, 0x23, 0xa1, 0xb0,
	0xc3, 0xf0, 0xe9, 0x17, 0x7a, 0x5d, 0x90, 0x38, 0xa1, 0x89, 0x9c, 0xba, 0xcd, 0xda, 0x24, 0x0c,
	0x44, 0x85, 0x84, 0x0e, 0x64, 0x48, 0x3c, 0x54, 0x4b, 0x78, 0x02, 0xae, 0xe6, 0x84, 0xa5, 0x38,
	0x95, 0x91, 0x9c, 0xe6, 0x44, 0x4c, 0xf9, 0x2c, 0x71, 0x5b, 0x1a, 0xe8, 0xf3, 0xda, 0x40, 0xae,
	0x01, 0x7a, 0x25, 0x20, 0x0a, 0x77, 0xac, 0xec, 0x41, 0x21, 0x82, 0x53, 0xf0, 0x76, 0x82, 0xe9,
	0xec, 0x2c, 0x9a, 0x67, 0xfa, 0xf0, 0xdb, 0x1a, 0xf3, 0xd3, 0xda, 0x98, 0xd7, 0x6c, 0xbb, 0x55,
	0x62, 0xa1, 0xb0, 0xab, 0xb7, 0x5f, 0xea, 0x1d, 0x4c, 0xc1, 0x36, 0xe3, 0xa9, 0x9c, 0xae, 0xb0,
	0x3a, 0x1a, 0xeb, 0xb3, 0xda, 0x58, 0xb6, 0xb5, 0xd7, 0xa3, 0xa1, 0xb0, 0x67, 0x05, 0x16, 0x4f,
	0x82, 0x9d, 0x55, 0x7f, 0x9d, 0x10, 0x3a, 0x99, 0x4a, 0x17, 0x68, 0xc4, 0x51, 0x6d, 0xc4, 0xf7,
	0x5e, 0xee, 0x57, 0x13, 0x0f, 0x85, 0xab, 0x89, 0xf0, 0x50, 0x4b, 0x0e, 0xb6, 0x54, 0xc7, 0xa2,
	0xdf, 0x1c, 0xd0, 0x29, 0xbb, 0x15, 0x7e, 0x04, 0x5a, 0xeb, 0x43, 0xb1, 0xd2, 0x8c, 0xe5, 0x0c,
	0x2c, 0x4c, 0xe0, 0x77, 0xa0, 0x33, 0x9e, 0x61, 0xca, 0x70, 0x3c, 0x23, 0x97, 0x8f, 0xbb, 0x23,
	0xdb, 0x8a, 0xf6, 0x72, 0x95, 0x9e, 0xf5, 0x26, 0xdd, 0x0a, 0xd1, 0x8c, 0x9c, 0xbf, 0x14, 0x89,
	0x9f, 0x1d, 0xd0, 0xbd, 0xab, 0x47, 0xda, 0x5d, 0x35, 0xd2, 0x6a, 0xd2, 0xa8, 0x35, 0x81, 0x02,
	0xd0, 0x26, 0x33, 0x3a, 0xa1, 0x8a, 0xb2, 0x1a, 0x3f, 0xed, 0xe1, 0xb5, 0xe5, 0xc2, 0xbb, 0x62,
	0xac, 0x0b, 0x0d, 0x0a, 0x4b, 0xa3, 0x4a, 0x96, 0x3f, 0x38, 0xa0, 0x75, 0x64, 0xe6, 0x34, 0x94,
	0xa0, 0x69, 0x9f, 0x09, 0xe7, 0xb2, 0xba, 0x1d, 0xda, 0xba, 0xf5, 0x6c, 0xfe, 0xff, 0xe1, 0x79,
	0xb0, 0x58, 0x95, 0x5c, 0xfe, 0x76, 0x40, 0xcf, 0xe6, 0x12, 0x92, 0x31, 0xcf, 0x93, 0xff, 0xb3,
	0x66, 0x2b, 0xb2, 0x9b, 0x6f, 0x82, 0xec, 0xf0, 0xde, 0xb3, 0xf3, 0xbe, 0xf3, 0xfc, 0xbc, 0xef,
	0xfc, 0x79, 0xde, 0x77, 0x9e, 0x5c, 0xf4, 0x1b, 0xcf, 0x2f, 0xfa, 0x8d, 0xdf, 0x2f, 0xfa, 0x8d,
	0xaf, 0x3e, 0x79, 0x25, 0xaa, 0x7a, 0x1e, 0x6f, 0xce, 0x70, 0x2c, 0x02, 0xf3, 0xd7, 0x73, 0xba,
	0xf6, 0xdf, 0xa3, 0x71, 0xe2, 0xa6, 0x7e, 0x68, 0x3e, 0xfe, 0x27, 0x00, 0x00, 0xff, 0xff, 0x11,
	0xe2, 0x3e, 0xd1, 0x19, 0x09, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IncentivePairs) > 0 {
		for iNdEx := len(m.IncentivePairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncentivePairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarketmaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DepositAmount) > 0 {
		for iNdEx := len(m.DepositAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DepositAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarketmaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IncentiveBudgetAddress) > 0 {
		i -= len(m.IncentiveBudgetAddress)
		copy(dAtA[i:], m.IncentiveBudgetAddress)
		i = encodeVarintMarketmaker(dAtA, i, uint64(len(m.IncentiveBudgetAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IncentivePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncentivePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncentivePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IncentiveWeight.Size()
		i -= size
		if _, err := m.IncentiveWeight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.MonthlyUptime.Size()
		i -= size
		if _, err := m.MonthlyUptime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.DailyUptime.Size()
		i -= size
		if _, err := m.DailyUptime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.RemnantThreshold.Size()
		i -= size
		if _, err := m.RemnantThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinWidth.Size()
		i -= size
		if _, err := m.MinWidth.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxSpread.Size()
		i -= size
		if _, err := m.MaxSpread.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinDepth.Size()
		i -= size
		if _, err := m.MinDepth.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMarketmaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintMarketmaker(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	if m.PairId != 0 {
		i = encodeVarintMarketmaker(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PairName) > 0 {
		i -= len(m.PairName)
		copy(dAtA[i:], m.PairName)
		i = encodeVarintMarketmaker(dAtA, i, uint64(len(m.PairName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Incentive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Incentive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Incentive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Claimable) > 0 {
		for iNdEx := len(m.Claimable) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Claimable[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarketmaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMarketmaker(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketMaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketMaker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketMaker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Eligible {
		i--
		if m.Eligible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PairId != 0 {
		i = encodeVarintMarketmaker(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMarketmaker(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarketmaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DepositRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMarketmaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PairId != 0 {
		i = encodeVarintMarketmaker(dAtA, i, uint64(m.PairId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMarketmaker(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMarketmaker(dAtA []byte, offset int, v uint64) int {
	offset -= sovMarketmaker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IncentiveBudgetAddress)
	if l > 0 {
		n += 1 + l + sovMarketmaker(uint64(l))
	}
	if len(m.DepositAmount) > 0 {
		for _, e := range m.DepositAmount {
			l = e.Size()
			n += 1 + l + sovMarketmaker(uint64(l))
		}
	}
	if len(m.IncentivePairs) > 0 {
		for _, e := range m.IncentivePairs {
			l = e.Size()
			n += 1 + l + sovMarketmaker(uint64(l))
		}
	}
	return n
}

func (m *IncentivePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PairName)
	if l > 0 {
		n += 1 + l + sovMarketmaker(uint64(l))
	}
	if m.PairId != 0 {
		n += 1 + sovMarketmaker(uint64(m.PairId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateTime)
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.MinDepth.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.MaxSpread.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.MinWidth.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.RemnantThreshold.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.DailyUptime.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.MonthlyUptime.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	l = m.IncentiveWeight.Size()
	n += 1 + l + sovMarketmaker(uint64(l))
	return n
}

func (m *Incentive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMarketmaker(uint64(l))
	}
	if len(m.Claimable) > 0 {
		for _, e := range m.Claimable {
			l = e.Size()
			n += 1 + l + sovMarketmaker(uint64(l))
		}
	}
	return n
}

func (m *MarketMaker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMarketmaker(uint64(l))
	}
	if m.PairId != 0 {
		n += 1 + sovMarketmaker(uint64(m.PairId))
	}
	if m.Eligible {
		n += 2
	}
	return n
}

func (m *Deposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovMarketmaker(uint64(l))
		}
	}
	return n
}

func (m *DepositRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMarketmaker(uint64(l))
	}
	if m.PairId != 0 {
		n += 1 + sovMarketmaker(uint64(m.PairId))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovMarketmaker(uint64(l))
		}
	}
	return n
}

func sovMarketmaker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMarketmaker(x uint64) (n int) {
	return sovMarketmaker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentiveBudgetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncentiveBudgetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositAmount = append(m.DepositAmount, types.Coin{})
			if err := m.DepositAmount[len(m.DepositAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentivePairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncentivePairs = append(m.IncentivePairs, IncentivePair{})
			if err := m.IncentivePairs[len(m.IncentivePairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarketmaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncentivePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncentivePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncentivePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PairName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDepth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSpread", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSpread.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWidth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinWidth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemnantThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemnantThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyUptime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DailyUptime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthlyUptime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MonthlyUptime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentiveWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncentiveWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarketmaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Incentive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Incentive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Incentive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Claimable = append(m.Claimable, types.Coin{})
			if err := m.Claimable[len(m.Claimable)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarketmaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketMaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketMaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketMaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eligible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eligible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMarketmaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarketmaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PairId", wireType)
			}
			m.PairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PairId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarketmaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarketmaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMarketmaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMarketmaker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMarketmaker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarketmaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMarketmaker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMarketmaker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMarketmaker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMarketmaker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMarketmaker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMarketmaker = fmt.Errorf("proto: unexpected end of group")
)
